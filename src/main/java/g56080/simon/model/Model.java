package g56080.simon.model;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.Timer;
import java.util.TimerTask;

import g56080.simon.view.ButtonColor;
import g56080.simon.view.ObservableListener;

import javafx.scene.paint.Color;
import java.util.function.Consumer;
import g56080.simon.controller.Controller;

/**
 * The application model dedicated to handle the applications' logic by generating the color sequence for example or
 * by starting the timer for each level.
 */
public class Model implements Observable{

    /**
     * State enumeration gathering all the possible game states.
     */
    public enum State{

        /**
         * Init state, when the game hasn't been started.
         */
        GAME_NOT_STARTED, 

        /**
         * Transition state before the game starts, when the timer is running.
         */
        GAME_STARTED_TIMER, 
        
        /**
         * Starting state, when the game has just started (whether it is a normal, last or longuest game)
         */
        GAME_STARTED, 
        
        /**
         * Game state, when the user has to play the color sequence.
         */
        PLAYER_TURN, 
        
        /**
         * Game state, when the sequence the user has to transcribe is running.
         */
        GAME_TURN, 
        
        /**
         * Transition state, when the user succeeds the level and can move on to the next one.
         */
        NEXT_LEVEL, 
        
        /**
         * Ending state, when the game is over (after a misplay or a timer exhaustion)
         */
        GAME_OVER, 
        
        /**
         * Ending state, when the timer the user has to adhere takes end.
         */
        TIME_IS_OVER;
    }
    
    private final List<ObservableListener> listeners;
    private final Chrono chrono;
    private Level level;
    private State state;
    private Queue<Color> gameSequence, playerSequence;
    private Queue<Color> longuestSequence, lastSequence;
    private Consumer<Controller> action;

    /**
     * Creates a new Model.
     */
    public Model(){
        listeners = new ArrayList<>();
        level = new Level();
        playerSequence = new ArrayDeque<>();
        gameSequence = new ArrayDeque<>();
        longuestSequence = new ArrayDeque<>();
        lastSequence = new ArrayDeque<>();
        chrono = new Chrono(event -> {
            state = State.TIME_IS_OVER;
            fireChange();
        });
    }

    /**
     * Init the model by clearing the color sequences generated by the game and played
     * by the user. The level and chrono are also reinitialized and the state becomes GAME_NOT_STARTED.
     */
    public void init(){
        state = State.GAME_NOT_STARTED;
        gameSequence.clear();
        playerSequence.clear();
        level.init(); 
        chrono.init();
        fireChange();
    }

    /**
     * Notifies the view(s) that the timer before the game starts has to be ran using the given
     * controller action to be performed when the timer takes end. After calling this method, the
     * action controller can be obtained by invoking {@link getActionController()}. The current 
     * state becomes GAME_STARTED_TIMER.
     *
     * @param consumer the action controller to be performed
     */
    public void timer(Consumer<Controller> consumer){
        state = State.GAME_STARTED_TIMER;
        action = consumer;
        fireChange();
    }

    /**
     * Notifies the view(s) that a new normal game has to be started. The current state becomes GAME_STARTED.
     */
    public void start(){
        state = State.GAME_STARTED;
        upgradeSequence();
        lastSequence = new ArrayDeque<>(gameSequence);
        fireChange();
    }

    /**
     * Notifies the view(s) that the game sequence the user has to transcribed has been played. The current
     * state becomes PLAYER_TURN.
     */
    public void sequenceOver(){
        state = State.PLAYER_TURN;
        chrono.start();
        chrono.upgrade();
        fireChange();
    }

    /**
     * Notifies the view(s) that the user succeeds the current level and can move to the next one. The current
     * state becomes GAME_TURN.
     */
    public void nextLevel(){
        state = State.GAME_TURN;
        level.upgrade();
        upgradeSequence();
        lastSequence = new ArrayDeque<>(gameSequence);
        if(gameSequence.size() > longuestSequence.size())
            longuestSequence = new ArrayDeque<>(gameSequence);
        fireChange();
    }

    /**
     * Notifies the view(s) that a new longuest game has to be started. A longuest game is represented by the
     * longuest sequence the user was able to play. The current state becomes GAME_STARTED.
     */
    public void longuest(){
        state = State.GAME_STARTED;
        if(longuestSequence.isEmpty()){
            upgradeSequence();
        } else{
            chrono.setLevel(longuestSequence.size());
            level.setLevel(longuestSequence.size());
            gameSequence.addAll(longuestSequence);
        }
        fireChange();
    }

    /**
     * Notifies the view(s) that a new last game has to be started. A last game is represented by the last color sequence
     * the user was trying to play. The current state becomes GAME_STARTED.
     */
    public void last(){
        state = State.GAME_STARTED;
        if(lastSequence.isEmpty()){
            upgradeSequence();
        } else{
            chrono.setLevel(lastSequence.size());
            level.setLevel(lastSequence.size());
            gameSequence.addAll(lastSequence);
        }
        fireChange();
    }

    /**
     * Notifies the view(s) that a click has occured on a color button of the given color. The current state
     * becomes NEXT_LEVEL if the user was able to properly transcribe the generated color sequence or becomes
     * GAME_OVER if a misplay occured.
     *
     * @param clickedColor the buttons' color on which the click has occured
     */
    public void click(Color clickedColor){
        Color gameColor = gameSequence.peek();
        if(gameColor != null && gameColor.equals(clickedColor)){
            gameSequence.poll();
            playerSequence.offer(clickedColor);
            if(gameSequence.isEmpty()){
                chrono.cancel();
                state = State.NEXT_LEVEL;
                fireChange();
            }
        } else{
            chrono.cancel();
            state = State.GAME_OVER;
            fireChange();
        }
    }

    @Override
    public void subscribe(ObservableListener listener){
        listeners.add(listener);
    }

    @Override
    public void unsubscribe(ObservableListener listener){
        listeners.remove(listener);
    }

    @Override
    public void fireChange(){
        listeners.stream().forEach(listener -> listener.update(state));
    }

    /**
     * Gets the last generated color sequence.
     *
     * @throws IllegalStateException if the current state is GAME_NOT_STARTED.
     * @return the last generated color sequence.
     */
    public Queue<Color> getSequence(){
        if(state.equals(State.GAME_NOT_STARTED))
            throw new IllegalStateException("Game not yet started");

        return gameSequence;
    }

    /**
     * Gets the current chrono time to which the user is subjected.
     *
     * @return the current chrono time.
     */
    public int getTime(){
        return chrono.getTime();
    }

    /**
     * Gets the current level the user is playing.
     *
     * @return the current level.
     */
    public int getLevel(){
        return level.getLevel();
    }

    /**
     * Gets the current state of this model.
     *
     * @return the current game state.
     */
    public State getState(){
        return state;
    }
    
    /**
     * Gets the action controller previously set by calling the {@link #timer(Consumer)} method. This
     * 'action' allows to invoke the right method after the timer before playing takes end.
     *
     * @return the action controller
     */
    public Consumer<Controller> getActionController(){
        return action;
    }

    /**
     * Generates a random number between the given start (inclusive) and end (exclusive) values.
     *
     * @param start the starting bound (inclusive)
     * @param end the ending bound (exclusive)
     *
     * @return a random number between start (inclusive) and end (exclusive).
     */
    public static int genRandom(int start, int end){ /* inc, exc */
        return (int) (Math.random() * (end - start) + start);
    }

    private void generateSequence(int count){
        ButtonColor[] colors = ButtonColor.values();
        for(int i = 0; i < count; i++){
            int colorIndex = genRandom(0, colors.length);
            gameSequence.offer(colors[colorIndex].getValue());
        }
    }

    private void upgradeSequence(){
        ButtonColor[] colors = ButtonColor.values();
        int colorIndex = genRandom(0, colors.length);

        playerSequence.offer(colors[colorIndex].getValue());
        gameSequence.addAll(playerSequence);
        playerSequence.clear();
    }
}
